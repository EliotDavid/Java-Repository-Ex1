public class Main {
    public static void main(String[] args) {

        // ======================================
        // 1, char = 정수형이다. 
        // 2. 각각의 데이터타입의 형태로 출력됨.
        // * int 형 타입에 문자로 초기화를 진행 하더라도 
        // 출력할 때에는 정수를 출력하고, char 타입에 
        // 정수로 초기화를 하더라도 출력할 때에는 문자가 출력됨
        // ======================================
        char c1 = 'A'; // 문자형 정상출력


        int i1 = c1; // int형인데 c1을 넣어준 상태임
                     // 이러면 c1변수가 가지고 있는 문자가 가지고 있는 아스키코드의 값을 i1에 대입하여 저장하라는 뜻

        char c2 = 66; // 데이터형에 따른 66이란 값이 가지고 있는 아스키코드표 문자를 c2에 대입하여 저장하라는 말

        int i2 = c1 + i1; // 대문자 A가 가지고 있는 정수값은 65임 + i1이 가지고 있는 값도 65이므로 130이 나옴

        System.out.println(c1);
        System.out.println(i1);
        System.out.println(c2);
        System.out.println(i2);

        // ======================================
        // 1. float = 실수 값의 마지막에 f 붙혀준다.
        // 2. double = 실수 값의 마지막에 d 붙혀준다.
        // * double = 실수 값의 마지막에 d가 없더라도 double 타입으로 판단.
        // ======================================

        // ** float vs double **
        float f = 3.141592653589793f; // 출력하면 소수점 7번쨰 자리까지 유효하다고 해서 7번째자리까지 나옴(그래서 7번쨰까지만 보면됨)

        double d = 3.141592653589793d; // 소수점 15번째 자리까지 유효하다고 해서 15번쨰 자리까지 나옴(15번째 자리까지만 보면 됨)
        double d2 = 3.141592653589793; //d2도 결과값이 d랑 같게 나올거임
                                        // d변수처럼 마지막에 d를 적어주지 않으면 그냥 d가 있는 것으로 취급을해서 8바이트로 취급한다고 함
        System.out.println(f);
        System.out.println(d);
        System.out.println(d2);


        //String c3 = "ABCDEDF"; // 문자열 데이터형



        // ======================================
        // [상수와 리터럴] ** 상수 : 변경을 안 하는 수
        // ** final = 상수 선언에 사용되는 키워드
        // final은 선언시에 최초 한번만 초기화 가능.
        // 그 이후에는 재설정이나 재초기화 안됨.
        // ======================================

        final double PI = 3.141592; // 이 값 자체에 d를 붙였거나 d를 붙이지 않든 모두 double로 판단되기 때문에
                                    // 굳이 뒤에 d를 안써도 됨

        // ** 상수로 선언 해놓고 값을 다시 변경하려고 할 때 ....
        // 이미 초기화해놓고 값을 다시 변경하려고 하면 에러가 남
        // PI = 3.141592653689793; // 이 코드에서 PI변수에 값을 변경시키려고 하는데 컴파일 오류가남
                                // 그 이유는 final의 특성 때문임

        // ======================================
        // [\n] = 줄바꿈
        // [\t] = 탭
        // [\\] = \
        // [\'] = '
        // [\"] = "
        // ======================================

        System.out.println("문자열\n출력");
        System.out.println("문자열\t출력");
        System.out.println("문자열\\출력");
        System.out.println("\'문\', \'자\', \'열\', \'출\', \'력\'");
        System.out.println("======================");
        System.out.println("'문'"+"'자'"+"'열'"+"'출'"+"'력'");
        System.out.println("\"문자열\" \"출력\"");

        // ======================================
        // ** [변수의 범위] **
        // 1. 특정 영역에서 생성된 변수는 해당 영역을 빠져나가면 더이상 사용할수 없다.
        // 
        // 2. 영역이 다르다면 변수명을 동일하게 지을수 있음
        //
        // 3. 특정 A라는 영역 내부에서 또다른 B영역을 포함한다면
        //    B영역은 A영역의 일부이다
        // ======================================

        int Number1 = 10;
        // 영역을 중괄호로 구분함
        {
            int Number2 = 1000;
            Number1 = 100;
        }

        System.out.println("Number : " + Number1);
        // System.out.println("Number2 : " + Number2); <- 이 코드는 변수의 영역부분 때문에 에러가 남

        {
            int Number2 = 100000;
            Number1 = 1000;
        } // 이 영역 안에서만 생성되고 존재하는 변수이지 이 영역을 나오면 이 영역 안에서 생성한 변수는 사라짐

        System.out.println(Number1);
        //System.out.println(Number2); <- Number2는 위 영역 안에서만 생성되고 존재하는 변수로, 그 영역을 빠져나오면 사라지게 되는 변수임
        // 또 1번째 영역의 Number2변수와 2번째 영역의 Number2변수는 변수 이름이 같아서 같은 변수로 보이지만 그렇지 않다
        // 전혀 다른 변수임
        // 1번째 영역 안에 있는 Number2는 1번째 영역의 Number2변수이고 2번째 영역 안에 있는 Number2는 2번째 영역의 Number2임
        // 동명이인 개념이라고 생각하면 됨
        // 부산에 살아도 부산진구에 사는 홍길동이 있고 해운대구에 사는 홍길동이 있듯이 서로 다른 객체의 개념으로 생각하면 됨
        // 그리고 이미 1번째 영역이 끝나는 시점에 1번째 영역에서 선언했던 Number2변수는 사라진 시점이고
        // 그러므로 뭐 2번째 영역에서 다시 Number2변수를 선언하면 당연히 Number2변수 이름으로 변수를 생성할 수 있지만
        // 서로 다른 영역에 있다면 동명이인의 변수이름으로 변수이름을 지을 수 있다고 함
    }
}